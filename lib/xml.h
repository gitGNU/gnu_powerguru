// 
//   Copyright (C) 2005 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//
#ifndef __XML_H__
#define __XML_H__

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <string>
#include <vector>
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#include <libxml/xmlreader.h>

#include "log.h"
#include "err.h"

class XMLAttr {
public:
  XMLAttr();
  ~XMLAttr();
  //private:
  char        *_name;
  char        *_value;
};

class XMLNode
{
public:
  XMLNode();
  ~XMLNode();

  int size() { return _children.size(); }
  std::string nodeName() 
  {
    return _name;
  }

  char *nodeValue()
  {
    return _value;
  }
  
  bool hasChildNodes()
  {
    if (_children.size() > 0) {
      return true;
    }
    return false;
  }
  
  std::vector<XMLNode *>childNodes()
  {
    return _children;
  }  

  XMLNode *operator [] (int x)
  {
    return _children[x];
  }
  
  XMLNode *operator = (XMLNode &node)
  {
    _name = node._name;
    _value = node._value;
    _children = node._children;
    _attributes = node._attributes;
    return this;
  }

  XMLNode *operator = (XMLNode *node)
  {
    _name = node->_name;
    _value = node->_value;
    _children = node->_children;
    _attributes = node->_attributes;
    return this;
  }
  //private:
  char               *_name;
  char               *_value;
  std::vector<XMLNode *>   _children;
  std::vector<XMLAttr *>   _attributes;
};

class XML {
 public:
  XML();
  XML(std::string xml_in);
  XML(struct node * childNode);
  virtual ~XML();

  // Methods
  bool parseDoc(xmlDocPtr document, bool mem); // This is the base method used by both parseXML() and load().
  bool parseXML(std::string xml_in); // Parses an XML document into the specified XML object tree.
  bool load(const char *filespec);  // Loads a document (specified by
                                    // the XML object) from a URL.

  void clear()
  {
    delete _nodes;
  }
  
  std::vector<XMLNode *> childNodes()
  {
    return _nodes->_children;
  }
  
  //  Returns true if the specified node has child nodes; otherwise, returns false.
  bool hasChildNodes()
  {
    return _nodes->_children.size();
  }
  
  XMLNode *extractNode(xmlNodePtr node, bool mem);
  XMLNode *processNode(xmlTextReaderPtr reader, XMLNode *node);
  
  const char *nodeNameGet() 
  {
    return _nodename;
  }
  
  int size() { return _nodes->size(); }
  
  XMLNode *operator [] (int x);
#if 0
  XMLNode *operator = (XMLNode &node)
  {
    dbglogfile << "%s: copy element "
               << node._name.c_str() << endl;
    _nodes = node;
  }
  
#endif
  XML *operator = (XMLNode *node)
  {
    _nodes = node;    
    return this;
  }
  
private:
  xmlDocPtr _doc;
  xmlNodePtr _firstChild;    
  const char  *_nodename;
  XMLNode     *_nodes;
};

int memadjust(int x);

#endif	// __XML_H__

