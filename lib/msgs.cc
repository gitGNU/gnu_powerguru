// 
//   Copyright (C) 2005 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <iostream>
#include <fstream>
#include <string>
#include <iterator>
#include <map>
#ifdef __STDC_HOSTED__
#include <sstream>
#else
#include <strstream>
#endif
#include <libxml/encoding.h>
#include <libxml/xmlwriter.h>
#include <libxml/debugXML.h>
#include "database.h"
#include "log.h"
#include "err.h"
#include "xml.h"
#include "msgs.h"
#include "tcputil.h"
#include "tcpip.h"

using namespace std;
Tcpip *Msgs::_tcpip;
std::map<std::string, Msgs::methodPtr_t> Msgs::_methods;

#define MY_ENCODING "ISO-8859-1"

Msgs::Msgs()
{
  // DEBUGLOG_REPORT_FUNCTION;
  Tcputil tu;
  tu.hostDataGet();
  
  _thisip = tu.hostIPNameGet();
  _thishost = tu.hostNameGet();

  _version = atof(VERSION);
}

Msgs::Msgs(std::string host, std::string ip)
{
  // DEBUGLOG_REPORT_FUNCTION;
  Tcputil tu;
  tu.hostDataGet();
  
  _thisip = tu.hostIPNameGet();
  _thishost = tu.hostNameGet();
  
  _remoteip = ip;
  _remotehost = host;

  _version = atof(VERSION);
}

Msgs::Msgs(Tcpip *tcpip)
{
  // DEBUGLOG_REPORT_FUNCTION;
  Tcputil tu;
  tu.hostDataGet();
  
  _thisip = tu.hostIPNameGet();
  _thishost = tu.hostNameGet();
  
  //  _remoteip = ip;
  //  _remotehost = host;
  _tcpip = tcpip;
  
  _version = atof(VERSION);
}

retcode_t
Msgs::initDaemon(void)
{

  // Top level node of the message
  _methods["powerguru"] = &Msgs::powerguruProcess;

  // initialization message
  _methods["helo"] = &Msgs::heloProcess;
  _methods["client"] = &Msgs::clientProcess;
  _methods["server"] = &Msgs::serverProcess;

  // Meter readings
  _methods["meters"] = &Msgs::metersProcess;
  _methods["charge-mps"] = &Msgs::chargeAmpsProcess;
  _methods["load-amps"] = &Msgs::loadAmpsProcess;
  _methods["pv-amps"] = &Msgs::pvAmpsProcess;
  _methods["pv-volts"] = &Msgs::pvVoltsProcess;
  _methods["daily-kwh"] = &Msgs::dailyKwhProcess;
  _methods["hertz"] = &Msgs::hertzProcess;
  _methods["battery-volts"] = &Msgs::batteryVoltsProcess;
  _methods["buy-amps"] = &Msgs::buyAmpsProcess;
  _methods["sell-amps"] = &Msgs::sellAmpsProcess;
  _methods["ac-volts-out"] = &Msgs::acVoltsOutProcess;
  _methods["ac1-volts-in"] = &Msgs::ac1InProcess;
  _methods["ac2-volts-in"] = &Msgs::ac2InProcess;

  // Status messages on the system
  _methods["status"] = &Msgs::statusProcess;

  // Configuration settings
  _methods["config"] = &Msgs::configProcess;

  //  _methods[""] = &Msgs::heloProcess;
}


// Add a function for handling an XML tag to the list.
void
Msgs::methodSet(string name, methodPtr_t func)
{
  // DEBUGLOG_REPORT_FUNCTION;
  _methods[name] = func;
}

// Get the function for an XML tag from the list.
Msgs::methodPtr_t
Msgs::methodGet(string name)
{
  //DEBUGLOG_REPORT_FUNCTION;
#if 1
  string                str;
  Msgs::methodPtr_t     ptr;

  std::map<std::string, Msgs::methodPtr_t>::const_iterator it;
  for (it = _methods.begin(); it != _methods.end(); it++) {
    //entry = it->second;
    str = it->first;
    ptr  = it->second;
    _body.str("");
    if (ptr != 0) {
      _body << " a function pointer";
    } else {
      _body << " doesn't have a function pointer";
    }
//     dbglogfile << "Looking for method for XML Tag \"" << name.c_str()
//                << "\" has " << _body.str().c_str() << endl;
    if (str == name) {
      return ptr;
    }
  }
#else
  dbglogfile << "\"" << name.c_str() << "\" method we want" << endl;
  return _methods[name];
#endif
}

// Call the function to process an XML node
retcode_t
Msgs::methodProcess(string name, XMLNode *node)
{
  // DEBUGLOG_REPORT_FUNCTION;
  //(this->*_methods.find(name)(node); 
  return (this->*_methods[name])(node);
}

// Dump all the pointer to methods for each XML Tag
void
Msgs::methodsDump(void)
{
  DEBUGLOG_REPORT_FUNCTION;
  string                name;
  Msgs::methodPtr_t     ptr;
  
  dbglogfile << "We have " << _methods.size() << " in function table" << endl;
  
  std::map<std::string, Msgs::methodPtr_t>::const_iterator it;
  for (it = _methods.begin(); it != _methods.end(); it++) {
    name = it->first;
    ptr  = it->second;
    _body.str("");
    if (ptr != 0) {
      _body << "a method pointer";
    } else {
      _body << "no pointer to method";
    }
    dbglogfile << "XML Tag \"" << name.c_str()
               << "\" has " << _body.str().c_str() << endl;
  }
}

Msgs::~Msgs()
{
  // DEBUGLOG_REPORT_FUNCTION;
  
}

void
Msgs::process(XMLNode *xml)
{
  DEBUGLOG_REPORT_FUNCTION;
  methodPtr_t   fptr;
  string        str;
  retcode_t     ret;
  int           i;

  str = xml->nameGet();
  fptr = methodGet(str);
  //methodsDump();
  
  if (fptr != 0) {
    dbglogfile << "XML tag \"" << str.c_str() << "\" has method pointer" << endl;
    ret = (this->*fptr)(xml);
  } else {
    dbglogfile << "WARNING: XML tag \"" << str.c_str() << "\" doesn't have a method pointer" << endl;
  }

  // Process the children too
  for (i=0; i<xml->childrenSize(); i++) {
    process(xml->childGet(i));
  }
  

#if 0
  //  struct Msgs::msg_data md;
  //  md.func_ptr = &Msgs::fooby;
  FPtr ptr = &Msgs::fooby;      // FIXME: test code
  (this->*ptr)(2);              // FIXME: test code
  _process_func.ptr = &Msgs::fooby; // FIXME: test code
  _process_func.ptr = &Msgs::fooby; // FIXME: test code
  _process_func.name = "Hey Now"; // FIXME: test code
  (this->*_process_func.ptr)(3); // FIXME: test code
  
  //msg_data.func_ptr
#endif

  
}

void
Msgs::dump(XMLNode *xml)
{
  // DEBUGLOG_REPORT_FUNCTION;
  int  child, length, i;
  XMLNode       *childnode;

  dbglogfile << "processing node " << xml->nameGet().c_str() << endl;

  // Process the node's value, if it has one.
  if (xml->valueGet().size() == 0) {
    dbglogfile << "No content for node " << xml->nameGet().c_str() << endl;
  } else {
    dbglogfile << "Content for node " << xml->nameGet().c_str()
               << " is " << xml->valueGet().c_str() << endl;
  }
  
  // Process the attributes, if any
  if (xml->attributesSize() == 0) {
    dbglogfile << "\tNo attributes for node " << xml->nameGet().c_str() << endl;
  } else {
    for (i=0; i<xml->attributesSize(); i++) {
      dbglogfile << "\tAttribute is " << xml->attribGet(i)->nameGet().c_str()
                 << " who's value is " << xml->attribGet(i)->valueGet().c_str() << endl;
    }
  }

  // Process the children, if there are any
  if (xml->childrenSize()) {
    dbglogfile << "\tProcessing " << xml->childrenSize() << " children nodes for "
               << xml->nameGet().c_str() << endl;
    for (child=0; child<xml->childrenSize(); child++) {
      childnode = xml->childGet(child);
      dump(childnode); // setup child node
    }
  } else {
    dbglogfile << "Node " << xml->nameGet().c_str() << " has no children" << endl;
  }
}

// These format client side messages to the daemon
string
Msgs::statusCreate(meter_data_t *md)
{
  // DEBUGLOG_REPORT_FUNCTION;
#if 1
  _body.str("");                // erase the current string
  _body << "<powerguru version=\"";
  _body << _version << "\">";
  _body << "<status>" << "</status>"; 
  _body << "</powerguru>";
  _body << ends;
  
  return _body.str();
#else
  int rc;
  xmlTextWriterPtr writer;
  xmlBufferPtr buf;
  xmlChar *tmp;
  
  if ((buf = xmlBufferCreate()) == NULL) {
    printf("testXmlwriterMemory: Error creating the xml buffer\n");
    return "";
  }
  
  if ((writer = xmlNewTextWriterMemory(buf, 0)) == NULL) {
    printf("testXmlwriterMemory: Error creating the xml writer\n");
    return "";
  }
  
  /* Start the document with the xml default for the version,
   * encoding ISO 8859-1 and the default for the standalone
   * declaration. */
  if ((rc = xmlTextWriterStartDocument(writer, NULL, MY_ENCODING, NULL)) < 0) {
    printf("testXmlwriterMemory: Error at xmlTextWriterStartDocument\n");
    return "";
  }
  
  if ((rc = xmlTextWriterStartElement(writer, BAD_CAST "powerguru")) < 0) {
    printf
      ("testXmlwriterMemory: Error at xmlTextWriterStartElement\n");
    return "";
  }
  
  if ((rc = xmlTextWriterStartElement(writer, BAD_CAST "status")) < 0) {
    printf
      ("testXmlwriterMemory: Error at xmlTextWriterStartElement\n");
    return "";
  }
    
  /* Add an attribute with name "version" and value "1.0" to status. */
  if ((rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "version",
                                          BAD_CAST "1.0")) < 0) {
    printf
      ("testXmlwriterMemory: Error at xmlTextWriterWriteAttribute\n");
    return "";
  }
  
  // end status tag
  if ((rc = xmlTextWriterEndElement(writer)) < 0) {
    printf("testXmlwriterMemory: Error at xmlTextWriterEndElement\n");
    return "";
  }
  
  /* Close the element named FOOTER. */
  if ((rc = xmlTextWriterEndElement(writer)) < 0) {
    printf("testXmlwriterMemory: Error at xmlTextWriterEndElement\n");
    return "";
  }
  
  if ((rc = xmlTextWriterEndDocument(writer)) < 0) {
    printf("testXmlwriterMemory: Error at xmlTextWriterEndDocument\n");
    return "";
  }
  
  xmlFreeTextWriter(writer);
  
  //    cerr << "Buffer says: " << (const char *) buf->content << endl;
  string str = (const char *) buf->content;
  xmlBufferFree(buf);
  return str;
#endif  
}

// Say "helo" to the connecting program to establish the messaging
// system. Both ends of the connection use this string to make sure
// they are speaking the same version of the protocol.
string
Msgs::heloCreate(float version)
{
  // DEBUGLOG_REPORT_FUNCTION;
  _body.str("");                // erase the current string
  _body << "<powerguru version=\"";
  _body << _version << "\">";
  _body << "<client ip=\"" << _remoteip << "\">" << _remotehost << "</client>"; 
  _body << "<server ip=\"" << _thisip   << "\">" << _thishost   << "</server>"; 
  _body << "</powerguru>";
  _body << ends;

  return _body.str();
}

string
Msgs::metersRequestCreate(std::string str) {
  DEBUGLOG_REPORT_FUNCTION;
  _body.str("");                // erase the current string
  _body << "<powerguru version=\"";
  _body << _version << "\">";
  _body << "<meters>" << str.c_str() << "</meters>"; 
  _body << "</powerguru>";
  _body << ends;

  return _body.str();  
}

string
Msgs::metersRequestCreate(xml_meters_e val) {
  DEBUGLOG_REPORT_FUNCTION;
  string str;

  switch (val) {
  case CHARGE_AMPS:
    str = "charge-amps";
    break;
  case AC_LOAD_AMPS:
    str = "load-amps";
    break;
  case BATTERY_VOLTS:
    str = "battery-volts";
    break;
  case AC_VOLTS_OUT:
    str = "ac-volts-out";
    break;
  case AC1_VOLTS_IN:
    str = "ac1-volts-in";
    break;
  case AC2_VOLTS_IN:
    str = "ac2-volts-in";
    break;
  case PV_AMPS_IN:
    str = "pv-amps-in";
    break;
  case PV_VOLTS_IN:
    str = "pv-volts-in";
    break;
  case BUY_AMPS:
    str = "buy-amps";
    break;
  case SELL_AMPS:
    str = "sell-amps";
    break;
  case DAILY_KWH:
    str = "daily-kwh";
    break;
  case HERTZ:
    str = "hertz";
    break;
  case TEMPCOMP_VOLTS:
    str = "tempcomp";
    break;
  default:
    break;                      // you should never be
  };

  return metersRequestCreate(str);
}

std::string
Msgs::metersResponseCreate(string type, int val) {
  DEBUGLOG_REPORT_FUNCTION;
  _body.str("");                // erase the current string
  _body << "<powerguru version=\"";
  _body << _version << "\">";
  _body << "<meters><" << type << ">";
  _body << val;
  _body << "</" << type << ">" << "</meters>"; 
  _body << "</powerguru>";
  _body << ends;

  return _body.str();  
}

std::string
Msgs::metersResponseCreate(string type, float val) {
  DEBUGLOG_REPORT_FUNCTION;
  _body.str("");                // erase the current string
  _body << "<powerguru version=\"";
  _body << _version << "\">";
  _body << "<meters><" << type << ">";
  _body << val;
  _body << "</" << type << ">" << "</meters>"; 
  _body << "</powerguru>";
  _body << ends;

  return _body.str();  
}

string
Msgs::configCreate(std::string tag, int value)
{
  // DEBUGLOG_REPORT_FUNCTION;
  _body.str("");                // erase the current string
  _body << "<powerguru>";
  _body << "<" << tag << ">" << value << "</" << tag << ">";
  _body << "</powerguru>";
  _body << ends;
  
  return _body.str();
}

void
Msgs::print_msg(std::string msg)
{
  // DEBUGLOG_REPORT_FUNCTION;
  int level = 1;
  int start = 0;
  size_t pos;
  string str, prefix, newmsg;
  const char *tabs[] = {
    "\r\n\t",
    "\r\n\t\t",
    "\r\n\t\t\t",
    "\r\n\t\t\t\t",
    "\r\n\t\t\t\t",
    "\r\n\t\t\t\t\t",
  };
  
  xmlDebugDumpString(stderr, (const xmlChar *)msg.c_str());
  //  cerr << "++++++++++++++++++++++" << endl;
  
  // Strip off the DTD header, as we're not bothering to validate
  // our XML.
  if ((pos = msg.find("?>\n", start)) != string::npos) {
    newmsg = msg.substr(pos+3, msg.size());
  } else {
    newmsg = msg;
  }  

  start = 0;
  while ((pos = newmsg.find('\n', start)) != string::npos) {
    newmsg.erase(pos, 1);
  }  

//   while ((pos = newmsg.find("><", start)) != string::npos) {
//     newmsg.insert(pos+1, "GGGGGG");
//   }  

  start = 0;
  while ((pos = newmsg.find('>', start)) != string::npos) {
    str = newmsg.substr(start, newmsg.find('>', start) - start + 1);
    start += str.size();
    if ((pos = str.rfind(">", start)) != string::npos) {
      //      str.insert(pos+1, "FFFF");
      str.insert(pos+1, tabs[level]);
      level++;
    }
    if ((pos = str.rfind("</", start)) != string::npos) {
      //      cerr << "EEEE";
      //      str.insert(pos, "EEEE");
      level--;
      str.insert(pos, tabs[level]);
    }
      
    cerr << str;
    //    cerr << prefix << str;
  }
  //cerr << newmsg.substr(start, newmsg.size()) << endl;
}

// These parse incoming messages for the daemon
retcode_t
Msgs::statusProcess(XMLNode *node)
{
  DEBUGLOG_REPORT_FUNCTION;
  dbglogfile << "WARNING: unimplemented method" << endl;

  return ERROR;                 // FIXME: implement this method
}

retcode_t
Msgs::heloProcess(XMLNode *node)
{
  DEBUGLOG_REPORT_FUNCTION;
  dbglogfile << "WARNING: unimplemented method" << endl;
  
  return ERROR;                 // FIXME: implement this method
}

retcode_t
Msgs::configProcess(XMLNode *node)
{
   DEBUGLOG_REPORT_FUNCTION;
  dbglogfile << "WARNING: unimplemented method" << endl;
  return ERROR;                 // FIXME: implement this method
}

retcode_t
Msgs::metersProcess(XMLNode *node)
{
  DEBUGLOG_REPORT_FUNCTION;

  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;

  string str = metersResponseCreate(node->valueGet(), 2);

  _tcpip->writeNet(str);
  return SUCCESS;
}

retcode_t
Msgs::serverProcess(XMLNode *node)
{
  //  DEBUGLOG_REPORT_FUNCTION;
  XMLAttr *attr;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->hasAttributes()) {
    if ((attr = node->attribGet(0))) {
      dbglogfile << "\tAttribute is \"" << attr->nameGet().c_str()
                 << "\" with a value of " << attr->valueGet().c_str() << endl;
      if (attr->valueGet() != _thisip) {
        dbglogfile << "WARNING: IP's don't match!!!!" << endl;
        return ERROR;
      }
    }
  }

  if ((node->valueGet() != _thishost)) {
    dbglogfile << "WARNING: Host's don't match!!!!" << endl;
    return ERROR;
  }

  dbglogfile << "Host and IP data match" << endl;
  return SUCCESS;
}

retcode_t
Msgs::clientProcess(XMLNode *node)
{
  //  DEBUGLOG_REPORT_FUNCTION;
  XMLAttr *attr;

  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (_remoteip.size() > 0) {
    if (node->hasAttributes()) {
      if ((attr = node->attribGet(0))) {
        dbglogfile << "\tAttribute is \"" << attr->nameGet().c_str()
                   << "\" with a value of " << attr->valueGet().c_str() << endl;
        if (attr->valueGet() != _remoteip) {
          dbglogfile << "WARNING: IP's don't match!!!!" << endl;
          return ERROR;
        }
      }
    }
  }

  if (_remotehost.size() != 0) {
    if ((node->valueGet() != _remotehost)) {
      dbglogfile << "WARNING: Host's don't match!!!!" << endl;
      return ERROR;
    }
  }

  return SUCCESS;
}

// Process the top level header tag.
retcode_t
Msgs::powerguruProcess(XMLNode *node)
{
  //  DEBUGLOG_REPORT_FUNCTION;
  XMLAttr *attr;

  _body.str("");
  _body << _version;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->hasAttributes()) {
    if ((attr = node->attribGet(0))) {
//       dbglogfile << "\tAttribute is \"" << attr->nameGet().c_str()
//                  << "\" with a value of " << attr->valueGet().c_str() << endl;
      if (_body.str() != attr->valueGet()) {
        dbglogfile << "Versions in header don't match!" << endl;
      } else {
        dbglogfile << "Versions in header match" << endl;        
      }
    }
  }

  return SUCCESS;
}

retcode_t
Msgs::chargeAmpsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::loadAmpsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::pvAmpsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::pvVoltsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::dailyKwhProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::hertzProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::batteryVoltsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::buyAmpsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::sellAmpsProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::acVoltsOutProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}
  
retcode_t
Msgs::ac1InProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

retcode_t
Msgs::ac2InProcess(XMLNode *node) {
  DEBUGLOG_REPORT_FUNCTION;
  
  dbglogfile << "Node is \"" << node->nameGet().c_str()
             << "\" with a value of " << node->valueGet().c_str() << endl;
      
  if (node->valueGet().size() <= 0) {
    dbglogfile << "ERROR: no value in messages!" << endl;
    return ERROR;
  }
      
  return SUCCESS;
}

